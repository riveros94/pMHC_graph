algorithm GenerateFrames(dm_raw, adj_raw, maps) is
  # Pré-processamento
  C := (dm_raw == 1)      # coerência booleana
  A := (adj_raw == 1)     # adjacência booleana
  zerar_diagonal(C) ; zerar_diagonal(A)   # C[ii]=True já vale; A[ii]=False
  K := número_de_nós(A)
  N_adj[u] := { v | A[u,v] = True }  para todo u

  frames := {}
  frames[0] := BaseEdges(A, maps)    # arestas i<j do grafo A

  # Estados globais de deduplicação
  seen_edge_sets    := ∅        # conjuntos de arestas já emitidos
  visited_states    := ∅        # pares (chosen_tuple, mask_signature)
  checked_node_sets := ∅        # conjuntos 'chosen' já avaliados
  next_id := 1

  # ordem de sementes por grau (decrescente)
  order_all := argsort_desc( grau(A,u) para u=0..K-1 )

  for node in order_all do
    inter := C[node,*]              # máscara de coerência inicial (com a semente)
    accepted := { node }            # conjunto escolhido começa pela semente

    frontier := { v in N_adj[node] | inter[v] = True }
    if frontier = ∅ then continue

    # expande a fronteira em grupos coerentes (cliques em C)
    initial_children := ExpandGroups(accepted, inter, frontier, C, A)

    stack := Pilha()
    for (sig, chosen_g, inter_g, frontier_g) in initial_children do
      if sig ∈ visited_states then continue
      visited_states := visited_states ∪ { sig }
      Empilha(stack, (chosen_g, inter_g, frontier_g))

    # DFS sobre estados; só aceita frame em nó-folha
    while stack ≠ ∅ do
      (chosen, inter_m, frontier_m) := Desempilha(stack)

      children := ExpandGroups(chosen, inter_m, frontier_m, C, A)

      if children ≠ ∅ then
        for child in children do
          (sig, c_g, m_g, f_g) := child
          if sig ∉ visited_states then
            visited_states := visited_states ∪ { sig }
            Empilha(stack, (c_g, m_g, f_g))
      else
        # nó-folha: tentar aceitar
        if |chosen| ≥ 4 then
          if chosen ∉ checked_node_sets then
            checked_node_sets := checked_node_sets ∪ { chosen }
            (ok, es) := ValidSubgraph(chosen, A)
            if ok then
              edge_key := CanonicalKey(es)   # p.ex. frozenset( sorted(u,v) )
              if edge_key ∉ seen_edge_sets then
                seen_edge_sets := seen_edge_sets ∪ { edge_key }
                frames[next_id] := ConvertToResidues(es, maps)
                next_id := next_id + 1

  return frames
